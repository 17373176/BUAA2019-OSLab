#Lab4系统调用-解析
##系统调用原理
&emsp;&emsp;运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。


  
一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作"保护模式"）。系统调用是这些规则的一个例外。其原理是进程先用适当的值填充寄存器，然后调用一个特殊的指令，这个指令会跳到一个事先定义的内核中的一个位置（当然，这个位置是用户进程可读但是不可写的）。在Intel CPU中，这个由中断0x80实现。硬件知道一旦你跳到这个位置，你就不是在限制模式下运行的用户，而是作为操作系统的内核--所以你就可以为所欲为。

进程可以跳转到的内核位置叫做sysem_call。这个过程检查系统调用号，这个号码告诉内核进程请求哪种服务。然后，它查看系统调用表(sys_call_table)找到所调用的内核函数入口地址。接着，就调用函数，等返回后，做一些系统检查，最后返回到进程（或到其他进程，如果这个进程时间用尽）。如果你希望读这段代码，它在<内核源码目录>/kernel/entry.S，Entry(system_call)的下一行。

##实现方法
MIPS中  
学会使用 syscall  
参数所使用的寄存器：$v0， $a0,  $a1  
返回值使用： $v0

  
关于系统调用，我们主要是以以下流程来进行的：

用户调用syscall特权指令触发异常，陷入内核
异常触发，pc值自动被硬件置为0x80000080，转向异常分发代码
trap_init识别是系统调用(8号异常)，为其分配处理函数handle_sys
将用户态下的参数拷贝到内核中，根据第1个参数为索引寻找系统调用表syscalltable
根据系统调用号在syscalltable中找到相应的函数后，转向对应函数处理
处理完成后，回到用户态，系统调用完成。

##实验步骤
系统调用相关宏函数定义在include/unistd.h中
###填写 user/syscall_wrap.S 中的 msyscall 函数
1. 设置syscall的参数；
2. 执行syscall;
3. 完成系统调用，返回 jr指令，跟一个nop  
`v0         用于置系统调用号
a0~a3      置前四个参数，后面的参数用栈传
syscall    系统调用触发指令`


栈帧方法宏(include/stackframe.h)
我们在进行用户态和内核态之间的切换，或者进程之间的切换时，需要保存现场。所谓现场，就是include/trap.h中所定义的trap结构体，其中包含的信息有：

32个寄存器的值
CP0部分寄存器的值
HI、LO两个乘除法寄存器的值
程序的指令计数器PC  

	//TF_SIZE是Trapframe寄存器的字节大小    
	macro STI                   //Set Interrupt，打开全局中断使能（允许中断）  
	.macro CLI                  //Close Interrupt，关闭全局中断使能（屏蔽中断）   
	.macro SAVE_ALL             //保存所有现场，将数据以Trapframe结构体形式存在sp为开头的空间中  
	.macro RESTORE_SOME         //恢复部分现场，此处的“部分”仅不包括sp的值  
	.macro RESTORE_ALL          //恢复所有现场，包括栈顶的位置  
	.macro RESTORE_ALL_AND_RET  //恢复现场并从内核态中返回  
	.macro get_sp               //获取栈顶位置，此函数会判断当前的状态是异常还是中断，从而决定栈顶是TIMESTACK还是KERNEL_SP。系统调用是编号为8的异常，进程切换是时钟中断信号。

###